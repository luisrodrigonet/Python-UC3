## 09.03 - Utilizando P√°ginas Din√¢micas em Templates Django

O objetivo principal das p√°ginas din√¢micas em Django √© exibir **conte√∫do espec√≠fico** de um objeto (como uma receita individual) usando um √∫nico arquivo de template. Isso √© alcan√ßado combinando um **URL din√¢mico**, uma **fun√ß√£o de view** que busca o objeto no banco de dados e a **Engine de Templates do Django** para renderizar os dados.

### üìù Resumo da Solu√ß√£o Proposta

Vamos criar uma p√°gina de **Detalhe da Receita** que aceitar√° o `ID` (ou `slug`) da receita na URL. A **View** buscar√° essa receita espec√≠fica no banco de dados e a passar√° para o template. O template usar√° a **linguagem de templates do Django (DTL)** para exibir dinamicamente o t√≠tulo, ingredientes, modo de preparo, etc.

### Passo 0: Cria√ß√£o da Aplica√ß√£o `receitas`

A aplica√ß√£o `receitas` conter√° toda a l√≥gica espec√≠fica das receitas.

```bash
# Crie a aplica√ß√£o dentro do projeto
python manage.py startapp receitas
```

A nova estrutura incluir√° a pasta `receitas`:

```
.
‚îú‚îÄ‚îÄ receitas/         # **Nossa nova aplica√ß√£o**
‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ admin.py
‚îÇ   ‚îú‚îÄ‚îÄ apps.py
‚îÇ   ‚îú‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ tests.py
‚îÇ   ‚îî‚îÄ‚îÄ views.py
```



**Configura√ß√£o Inicial (`settings.py`)**

√â fundamental informar ao Django que a nova aplica√ß√£o existe.

Abra o arquivo **`ChefDjango/settings.py`** e adicione `'receitas'` √† lista `INSTALLED_APPS`.

```python
# ChefDjango/settings.py

INSTALLED_APPS = [
    # Django Padr√£o
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Aula 09 - Nossas Aplica√ß√µes Personalizadas
    'receitas', 
    # Aula 09 -  Adicionar aqui se for usar a biblioteca
    # 'django_select2', 
]
```

**Conex√£o das URLs (`urls.py` do Projeto)**

Precisamos rotear o tr√°fego que chega ao caminho principal para a nossa aplica√ß√£o `receitas`.

Abra o arquivo **`config/urls.py`** (o arquivo de URLs do projeto) e inclua as rotas da aplica√ß√£o.

```python
# config/urls.py (Principal)

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    
    # Aula 09 - Conecta todas as URLs definidas em 'receitas.urls' ao caminho base ('')
    path('', include('receitas.urls')), 
]
```


### Passo 1: O Modelo (`models.py`)

Primeiro, definimos o modelo da nossa receita.

```python
# receitas/models.py

from django.db import models
from django.contrib.auth.models import User

class Categoria(models.Model):
    """Modelo para as categorias das receitas (Ex: Sobremesa, Jantar)."""
    nome = models.CharField(max_length=100)
    
    def __str__(self):
        return self.nome

class Receita(models.Model):
    """Modelo principal para as receitas."""
    
    # Campo para a chave prim√°ria que ser√° usada na URL
    # O Django j√° cria um campo 'id' automaticamente, mas o usaremos implicitamente
    
    titulo = models.CharField(max_length=200)
    ingredientes = models.TextField()
    modo_preparo = models.TextField()
    tempo_preparo = models.IntegerField(help_text='Em minutos')
    data_publicacao = models.DateTimeField(auto_now_add=True)
    publicada = models.BooleanField(default=False)
    
    # Rela√ß√£o ManyToMany: Uma receita pode ter v√°rias categorias e uma categoria pode ter v√°rias receitas.
    categorias = models.ManyToManyField(Categoria, related_name='receitas')
    
    # Chave Estrangeira: Uma receita pertence a um √∫nico usu√°rio/autor.
    autor = models.ForeignKey(User, on_delete=models.CASCADE)
    
    def __str__(self):
        return self.titulo
```

### Passo 2: O URL Din√¢mico (`urls.py`)

Precisamos de uma rota que aceite um identificador para a receita. Usaremos o `pk` (Primary Key).

```python
# receitas/urls.py

from django.urls import path
from . import views

urlpatterns = [
    # Rota de listagem de todas as receitas
    path('', views.lista_receitas, name='lista_receitas'),
    
    # Rota Din√¢mica: <int:pk> captura um n√∫mero inteiro e o passa como argumento 'pk' para a view.
    path('receita/<int:pk>/', views.detalhe_receita, name='detalhe_receita'),
]
```

### Passo 3: A View que Busca os Dados (`views.py`)

A view √© o cora√ß√£o da l√≥gica. Ela recebe o `pk` da URL, busca a receita e envia o objeto para o template.

```python
# receitas/views.py

from django.shortcuts import render, get_object_or_404
from .models import Receita

def lista_receitas(request):
    """View para listar todas as receitas publicadas."""
    receitas_publicadas = Receita.objects.filter(publicada=True).order_by('-data_publicacao')
    context = {'receitas': receitas_publicadas}
    return render(request, 'receitas/lista.html', context)

def detalhe_receita(request, pk):
    """
    View para exibir os detalhes de uma receita espec√≠fica.
    
    :param request: O objeto HttpRequest.
    :param pk: A chave prim√°ria (ID) da receita, capturada da URL.
    """
    # 1. Busca no banco de dados: 
    # get_object_or_404 busca o objeto pelo pk e, se n√£o encontrar, lan√ßa um erro 404.
    receita = get_object_or_404(Receita, pk=pk, publicada=True)
    
    # 2. Cria√ß√£o do contexto:
    # O objeto 'receita' √© empacotado em um dicion√°rio para ser enviado ao template.
    context = {
        'receita': receita
    }
    
    # 3. Renderiza√ß√£o:
    # O template 'detalhe.html' √© renderizado com os dados da receita.
    return render(request, 'receitas/detalhe.html', context)
```

### Passo 4: O Template Din√¢mico (`detalhe.html`)

O template usa a sintaxe DTL para acessar as propriedades do objeto `receita` passado pela view.

```html
{% extends "base.html" %} 
{% block title %}{{ receita.titulo }}{% endblock %}

{% block content %}

    <div class="container my-5">
        <h1 class="text-primary mb-4">{{ receita.titulo }}</h1>
        <hr>

        <p class="text-muted">
            <i class="fas fa-clock"></i> Tempo de Preparo: <strong>{{ receita.tempo_preparo }} minutos</strong> | 
            <i class="fas fa-user"></i> Por: <strong>{{ receita.autor.username }}</strong>
        </p>

        <p>
            <strong>Categorias:</strong> 
            {% for categoria in receita.categorias.all %}
                <span class="badge bg-secondary">{{ categoria.nome }}</span>
            {% endfor %}
        </p>

        <div class="row mt-4">
            <div class="col-md-6">
                <h2 class="text-secondary">Ingredientes</h2>
                <p>{{ receita.ingredientes|linebreaksbr }}</p>
            </div>
            <div class="col-md-6">
                <h2 class="text-secondary">Modo de Preparo</h2>
                <p>{{ receita.modo_preparo|linebreaksbr }}</p>
            </div>
        </div>
        
        <a href="{% url 'lista_receitas' %}" class="btn btn-outline-primary mt-4">
            <i class="fas fa-arrow-left"></i> Voltar para a lista
        </a>
    </div>

{% endblock %}
```

### üí° Observa√ß√µes Adicionais

#### Chave Prim√°ria vs. Slug

  * **`pk` (Primary Key/ID):** √â a forma mais simples e r√°pida de buscar um objeto no banco de dados, como fizemos no exemplo (`receita/<int:pk>/`).
  * **Slug:** Um **`slug`** √© uma vers√£o amig√°vel e limpa do t√≠tulo (ex: `pao-de-queijo-simples`). √â mais recomendado para URLs que ser√£o compartilhadas e indexadas por motores de busca (SEO). Se voc√™ quiser usar um slug, o campo deve ser adicionado ao modelo e a URL mudaria para `receita/<slug:slug>/`. A view buscaria o objeto por `slug=slug` em vez de `pk=pk`.

#### Uso do `get_object_or_404`

Sempre use a fun√ß√£o `get_object_or_404` (importada de `django.shortcuts`) em suas views para buscar objetos din√¢micos.

  * **Vantagem:** Se um usu√°rio tentar acessar uma URL com um ID de receita que n√£o existe (ex: `/receita/9999/`), o Django ir√° automaticamente retornar uma p√°gina de **erro 404 "Not Found"** amig√°vel, em vez de falhar com um erro 500 interno no servidor.

#### Campos ManyToMany e `django-select2` (Dica de Ferramenta)

No nosso modelo `Receita`, usamos um campo **`ManyToManyField`** para `categorias`. Para aprimorar a experi√™ncia do usu√°rio (UX) ao adicionar ou editar uma receita no formul√°rio do Admin ou em formul√°rios personalizados, recomendo usar a biblioteca **`django-select2`**.

**O que faz:** Ele substitui o `widget` padr√£o do campo de sele√ß√£o m√∫ltipla (que pode ser desajeitado com muitas op√ß√µes) por um dropdown pesquis√°vel e com *tagging* (para criar novas categorias na hora), tornando a sele√ß√£o de itens muito mais eficiente.

**Aplica√ß√£o em `ManyToMany`:** Para us√°-lo em um `ManyToMany` (como o campo `categorias`):

1.  **Instale** a biblioteca (`pip install django-select2`).
2.  **Configure** o widget no seu `forms.py` (ou no `admin.py`):

<!-- end list -->

```python
# Exemplo de como configurar em um ModelAdmin

from django_select2.forms import Select2MultipleWidget
from .models import Receita

class ReceitaAdmin(admin.ModelAdmin):
    # ... outros campos
    
    # Sobrescrevemos o widget padr√£o para o campo 'categorias'
    formfield_overrides = {
        models.ManyToManyField: {'widget': Select2MultipleWidget},
    }

admin.site.register(Receita, ReceitaAdmin)
```

Isso garante que, ao editar uma receita, o campo de sele√ß√£o de categorias utilize a interface aprimorada do Select2.

