## üó∫Ô∏è09.02 - Isolamento de URls

Imagine seu site Django como uma cidade grande. Quando voc√™ digita um endere√ßo (uma URL) no navegador, o Django precisa de um **mapa** para saber para qual pr√©dio (uma **View**) enviar voc√™. Este mapa √© chamado de **URLconf** (Configura√ß√£o de URLs).

### :one: O Ponto de Partida: O Mapa Principal (`urls.py` do Projeto)

Todo projeto Django tem um arquivo principal de URLs, geralmente localizado na pasta principal do seu projeto (a mesma onde fica `settings.py`). Ele √© o **mapa-m√∫ndi** do seu site.

Quando um usu√°rio acessa `meusite.com/`, o Django olha para este arquivo primeiro:

#### Exemplo: `projeto/urls.py`

```python
# projeto/urls.py
# O mapa-m√∫ndi do seu site

from django.contrib import admin
from django.urls import path, include # Importamos as ferramentas de roteamento

urlpatterns = [
    # 1. Rota Fixa: Mapeia o caminho 'admin/' para o painel de administra√ß√£o
    # Quando o usu√°rio digita meusite.com/admin/, o Django sabe o que fazer.
    path('admin/', admin.site.urls),

    # 2. Isolamento de URLs: Onde a m√°gica da organiza√ß√£o acontece!
    # Quando o usu√°rio digita meusite.com/blog/, o Django PARA de olhar este arquivo
    # e manda ele procurar as rotas no mapa (urls.py) do nosso aplicativo 'blog'.
    path('blog/', include('blog.urls')), 
    
    # Exemplo de App de Usu√°rios:
    path('usuarios/', include('usuarios.urls')),
]
```

  * **`path()`**: A ferramenta que usamos para desenhar uma rota no mapa.
  * **`admin.site.urls`**: √â como se fosse o "Pr√©dio do Governo" do Django, que j√° vem pronto.
  * **`include()`**: A ferramenta mais importante\! Ela permite que voc√™ **divida o mapa em peda√ßos menores**, delegando a responsabilidade de rotas espec√≠ficas para cada aplica√ß√£o (App) do seu projeto. Isso √© o **"Isolamento de URLs"**\!

### :two: A Chave da Organiza√ß√£o: O Isolamento de URLs com `include()`

Em projetos reais, voc√™ ter√° v√°rios aplicativos (apps) (ex: `blog`, `loja`, `perfil`). Se voc√™ colocasse todas as URLs no arquivo principal, ele ficaria enorme e imposs√≠vel de gerenciar.

O `include()` resolve isso, criando um **mapa local** dentro de cada App.

#### Exemplo: O Mapa Local do App `blog`

Para o App `blog` funcionar, precisamos criar um arquivo `urls.py` dentro da pasta dele:

```python
# blog/urls.py
# O mapa local do App 'blog'

from django.urls import path
from . import views # Importa as "Views" (os pr√©dios/fun√ß√µes que fazem o trabalho)

# ‚≠êÔ∏è PASSO CRUCIAL PARA ISOLAMENTO (Namespacing)
app_name = 'blog' 

urlpatterns = [
    # Rota 1: Lista de Posts
    # URL completa: meusite.com/blog/ (o 'blog/' veio do include no projeto principal)
    path('', views.lista_posts, name='lista'), 
    
    # Rota 2: Detalhe do Post
    # URL completa: meusite.com/blog/5/ ou meusite.com/blog/meu-primeiro-post/
    # O <int:post_id> ou <slug:slug_do_post> captura um valor na URL e o passa 
    # para a View. O 'int:' garante que √© um n√∫mero!
    path('<int:post_id>/', views.detalhe_post, name='detalhe'), 
    
    # Rota 3: Novo Post
    # URL completa: meusite.com/blog/novo/
    path('novo/', views.criar_post, name='novo'),
]
```

#### O que √© o `app_name = 'blog'` e por que ele √© crucial?

Isso se chama **Namespacing** (Espa√ßo de Nomes). Ele garante o **isolamento total** das suas URLs.

**Problema sem Namespacing:** Se voc√™ tiver um App `blog` e um App `loja`, e ambos tiverem uma URL chamada `detalhe`, o Django n√£o saberia qual chamar quando voc√™ pedisse a URL `detalhe`.

**Solu√ß√£o com Namespacing:**
Ao definir `app_name = 'blog'`, voc√™ diz: "Todas as URLs neste arquivo pertencem ao dom√≠nio 'blog'".

### :three: Evitando Endere√ßos Fixos: O Poder do "Reverso de URL"

No desenvolvimento web, **nunca** devemos escrever URLs diretamente no c√≥digo (ex: `<a href="/blog/5/">`). E se voc√™ mudar o caminho de `/blog/` para `/artigos/`? Teria que mudar o c√≥digo em v√°rios lugares.

O Django resolve isso com a fun√ß√£o **Reverso de URL**, usando o nome que voc√™ deu na fun√ß√£o `path` (`name='...'`).

Ao usar o namespace, voc√™ acessa a URL isolada de forma segura:

| Onde Usar | Como Chamar (Sintaxe Isolada) | Explica√ß√£o |
| :--- | :--- | :--- |
| **Templates HTML** | `{% url 'blog:detalhe' post.id %}` | Pede ao Django a URL completa do App **blog**, com o nome **detalhe**, usando o ID do post como argumento. |
| **C√≥digo Python (Views)** | `from django.urls import reverse` <br> `url = reverse('blog:lista')` | Pede ao Django a URL completa do App **blog**, com o nome **lista**. |
| **Redirecionamento** | `return redirect('blog:detalhe', post_id=5)` | Redireciona o usu√°rio para a URL do App **blog**, com o nome **detalhe**, passando o ID 5. |

### :four: Observa√ß√µes Adicionais

#### ‚û°Ô∏è A Ordem das Rotas √© Importante\!

O Django √© pregui√ßoso (no bom sentido\!). Ele verifica as URLs **na ordem em que elas aparecem** no `urlpatterns` e para na primeira que der "match".

  * Se voc√™ colocar uma rota gen√©rica primeiro, ela pode bloquear rotas mais espec√≠ficas:


```python
# blog/urls.py (EXEMPLO DE ERRO)
urlpatterns = [
    # ‚ùå Rota GERAL: Vai capturar TUDO, inclusive a rota 'novo/'!
    path('<str:slug>/', views.detalhe_post, name='detalhe'), 
    path('novo/', views.criar_post, name='novo'), # Nunca ser√° acessada!
]
```

  * **A Regra √©:** Coloque as rotas **mais espec√≠ficas (fixas)** antes das rotas **mais gen√©ricas (com vari√°veis)**.

<!-- end list -->

```python
# blog/urls.py (CORRETO)
urlpatterns = [
    path('novo/', views.criar_post, name='novo'), # ESPEC√çFICA (texto fixo)
    path('<str:slug>/', views.detalhe_post, name='detalhe'), # GEN√âRICA (vari√°vel)
]
```

#### ‚û°Ô∏è Convers√£o de Tipo na Rota

Note o uso de `<int:post_id>`:

  * **`int:`**: Chamado de **Converter**. Garante que o valor capturado na URL seja um n√∫mero inteiro (`int`) no Python, e n√£o apenas uma string (texto).
  * Os conversores padr√£o s√£o: `<str:>`, `<int:>`, `<slug:>`, `<uuid:>`, `<path:>` (para capturar caminhos inteiros, incluindo barras).

