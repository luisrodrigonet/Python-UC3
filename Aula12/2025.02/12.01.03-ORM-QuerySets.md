# Django ORM: QuerrySets üõ∞Ô∏è

O Django ORM (`Object-Relational Mapper`) √© uma das ferramentas mais poderosas do framework Django. Ele permite que voc√™ **interaja com o banco de dados usando c√≥digo Python** orientado a objetos, **sem necessidade de escrever SQL diretamente**. O ORM traduz suas **classes Python em tabelas de banco de dados** e suas opera√ß√µes em Python para queries SQL.

Para contextualizar os conceitos que vamos aprender, vamos desenvolver uma aplica√ß√£o de **gest√£o de biblioteca**, que inclui modelos para livros, autores, editoras, empr√©stimos e usu√°rios.

## 12. QuerySets - Conjuntos de Consulta

Um `QuerySet` representa uma cole√ß√£o de objetos do banco de dados. Ele permite filtrar, ordenar e manipular dados sem executar a `query` at√© que seja necess√°rio (`lazy evaluation`).

A **lazy evaluation** (avalia√ß√£o pregui√ßosa) no Django refere-se ao fato de que um `QuerySet` n√£o executa a `query` SQL no banco de dados imediatamente quando √© criado ou modificado, mas apenas quando seus dados s√£o realmente necess√°rios ‚Äî ou seja, a execu√ß√£o √© **adiada at√© o √∫ltimo momento poss√≠vel**.

üö® **Como funciona?**

Quando voc√™ chama m√©todos como `filter()`, `exclude()`, `order_by()`, um novo `QuerySet` √© constru√≠do, representando uma opera√ß√£o a ser feita no banco, mas nenhum acesso ao banco ocorre ainda.

A consulta ao banco s√≥ √© executada quando o resultado do `QuerySet` precisa ser acessado, por exemplo:

- Iterando sobre ele (`for obj in qs`)
- Convertendo para lista (`list(qs)`)
- Chamando m√©todos como `.count()`, `.exists()`, `.first()`, `.last()`
- Acessando um elemento por √≠ndice (`qs[0]`)
- Usando em templates Django (pois acessa os dados para renderizar)

üöÄ **Benef√≠cios**

- **Performance otimizada**: Evita executar `queries` desnecess√°rias ao banco, reduzindo tr√°fego e carga.
- **Composi√ß√£o de consultas**: Permite encadear v√°rios filtros e opera√ß√µes para construir gradualmente a `query` ideal antes da execu√ß√£o.
- **Melhor uso de mem√≥ria**: Dados s√≥ s√£o carregados quando realmente usados.

üíª **Exemplo 01**

```python
books = Book.objects.filter(author="J.K. Rowling")  # <-- Nenhuma query √© executada aqui

# A query s√≥ √© executada no for, quando os dados s√£o necess√°rios
for book in books:
    print(book.title)
```

ü§ñ **Quando o QuerySet √© avaliado?**

- Ao iterar (ex: `for`)
- Ao converter para lista (`list(qs)`)
- Ao chamar `.count()`, `.exists()`, `.first()`, `.last()`
- Ao fatiar (`qs[:10]`)
- Ao acessar em templates

üì¢ **Cuidados**

- Repetir uso do mesmo `QuerySet` pode disparar m√∫ltiplas `queries` se n√£o for armazenado (`cached`).
- Para evitar, armazene o resultado em uma lista ou vari√°vel.

### 12.1. M√©todos que Retornam QuerySets

#### üõ£Ô∏è **all()**

Retorna todos os objetos.

```python
todos_livros = Livro.objects.all()
```

#### üõ£Ô∏è **filter()**

Filtra objetos que correspondem aos crit√©rios.

O m√©todo **`filter()`** do Django √© usado para filtrar um QuerySet, retornando um novo QuerySet que cont√©m apenas os objetos que atendem aos crit√©rios especificados nos argumentos.

üö® **Como funciona?**

- `filter()` recebe **argumentos** no formato de pares **chave-valor**, onde a chave √© o nome do campo do modelo, possivelmente **seguida por `__` e um tipo de filtro** (lookup), e o valor √© o valor esperado para o filtro.
- Ele traduz esses filtros para cl√°usulas SQL `WHERE`, restringindo os registros retornados.
- Retorna sempre um novo `QuerySet`, permitindo encadeamento de m√∫ltiplos filtros.

üíª **Exemplo 01**

```python
# Filtra livros com t√≠tulo contendo "wild"
livros = Livro.objects.filter(titulo__icontains="wild")

# Filtra livros publicados at√© o ano de 2006
livros = Livro.objects.filter(ano_publicacao__lte=2006)

# Filtra livros que possuem 'django' no t√≠tulo e foram publicados em 2023
livros = Livro.objects.filter(titulo__icontains='django', ano_publicacao=2023)
```

üíª **Exemplo 02**

```python
# Filtragem simples
livros_2023 = Livro.objects.filter(ano_publicacao=2023)

# M√∫ltiplos filtros (AND)
livros = Livro.objects.filter(
    disponivel=True,
    ano_publicacao__gte=2020
)

# Atrav√©s de relacionamentos
livros_editora = Livro.objects.filter(editora__nome="Companhia das Letras")

# Lookups complexos
livros = Livro.objects.filter(
    titulo__icontains="django",  # Cont√©m "django" (case-insensitive)
    preco__lte=50.00,            # Pre√ßo menor ou igual a 50
    ano_publicacao__range=(2020, 2023)  # Entre 2020 e 2023
)
```

ü§ñ **Lookups dispon√≠veis:**
- `exact`: Igualdade exata (padr√£o)
- `iexact`: Igualdade case-insensitive
- `contains`: Cont√©m (case-sensitive)
- `icontains`: Cont√©m (case-insensitive)
- `startswith / istartswith`: Come√ßa com
- `endswith / iendswith`: Termina com
- `gt / gte`: Maior que / Maior ou igual
- `lt / lte`: Menor que / Menor ou igual
- `range`: Entre valores
- `in`: Est√° na lista
- `isnull`: √â NULL


üöè **Caracter√≠sticas importantes**

- Pode receber **m√∫ltiplos filtros** que s√£o combinados com **AND**.
- Pode receber **objetos** `Q` para **filtros complexos com OR, AND, NOT**.
- N√£o executa a consulta imediatamente (**lazy evaluation**) ‚Äî a `query` s√≥ √© feita quando o queryset √© avaliado.
- Permite cria√ß√£o din√¢mica e fluente da consulta ao banco.

#### üõ£Ô∏è **exclude()**

Retorna objetos que N√ÉO correspondem aos crit√©rios.

```python
# Livros que n√£o s√£o de 2023
livros = Livro.objects.exclude(ano_publicacao=2023)

# Excluindo m√∫ltiplos crit√©rios
livros = Livro.objects.exclude(
    disponivel=False
).exclude(
    preco__gt=100
)
```

#### üõ£Ô∏è **order_by()**

Ordena os resultados.

```python
# Ordem crescente
livros = Livro.objects.order_by('titulo')

# Ordem decrescente
livros = Livro.objects.order_by('-ano_publicacao')

# M√∫ltiplos campos
livros = Livro.objects.order_by('editora__nome', '-ano_publicacao')

# Ordem aleat√≥ria
livros = Livro.objects.order_by('?')

```

#### üõ£Ô∏è **distinct()**

Remove duplicatas.

```python
# Editoras √∫nicas de livros dispon√≠veis
editoras = Livro.objects.filter(
    disponivel=True
).values('editora').distinct()
```

#### üõ£Ô∏è **select_related()**

Otimiza `queries` com `JOINs` (para `ForeignKey` e `OneToOne`).

O m√©todo **`select_related()`** no Django ORM √© usado para otimizar consultas `SQL` que envolvem relacionamentos de tipo **ForeignKey** ou **OneToOneField**. Ele realiza um **JOIN SQL** para buscar os dados do modelo principal junto com os dados dos modelos relacionados em uma √∫nica consulta ao banco de dados.

üö® **Como funciona?**

- Quando voc√™ usa `select_related('campo_relacionado')`, o Django gera uma `query` `SQL` que faz um `JOIN` entre a tabela principal e a tabela relacionada, trazendo todos os dados juntos.
- Isso evita a chamada adicional ao banco para buscar os dados relacionados, que normalmente ocorreria ao acessar os atributos relacionados em um `loop` (problema conhecido como ‚ÄúN+1 queries‚Äù).
- **N√£o funciona para relacionamentos ManyToManyField** ou relacionamentos reversos (neste caso, usa-se `prefetch_related()`).

üíª **Exemplo 01**

```python
# Sem otimiza√ß√£o - faz 1 query + N queries (uma para cada livro)
livros = Livro.objects.all()
for livro in livros:
    print(livro.editora.nome)  # Query extra para cada livro

# Com select_related - faz apenas 1 query com JOIN
livros = Livro.objects.select_related('editora').all()
for livro in livros:
    print(livro.editora.nome)  # Sem query extra

# M√∫ltiplos relacionamentos
livros = Livro.objects.select_related(
    'editora',
    'editora__pais'
)
```

üöÄ **Benef√≠cios**

- **Melhora significativa de performance** em consultas que acessam dados de relacionamentos ForeignKey/OneToOne.
- Reduz a quantidade de queries feitas ao banco, diminuindo a lat√™ncia e carga.
- Facilita o acesso direto a dados relacionados carregados, sem custo adicional.

üì¢ **Restri√ß√µes**

- Apenas para **relacionamentos de um para muitos e um para um**.
- Para **relacionamentos muitos para muitos e reversos**, usar `prefetch_related()`.
- Pode trazer muitos dados na mesma query, cuidado com consultas que incluem muitos relacionamentos e/ou campos pesados.

Em resumo, o `select_related()` cria `joins` `SQL` para pr√©-carregar objetos relacionados `ForeignKey` ou `OneToOne` eficientemente, evitando consultas extras e otimizando o acesso aos dados relacionados no Django ORM.


#### üõ£Ô∏è **prefetch_related()**

Otimiza `queries` para `ManyToMany` e reverse `ForeignKey`.

O m√©todo **`prefetch_related()`** no Django ORM √© usado para otimizar consultas que envolvem relacionamentos do tipo **muitos-para-muitos (ManyToManyField)** ou **muitos-para-um** (relacionamentos reversos de `ForeignKey`), onde o m√©todo `select_related()` n√£o funciona porque n√£o suporta esses casos.

üö® **Funcionamento detalhado**

- Diferente do `select_related()`, que faz um JOIN SQL para trazer os dados relacionados em uma √∫nica consulta, o `prefetch_related()` realiza **duas consultas SQL separadas**: uma para o modelo principal e outra para os dados relacionados.
- Ap√≥s trazer os dados relacionados em uma query separada, o Django **faz a jun√ß√£o dos dados em Python na mem√≥ria**, associando os objetos relacionados aos seus objetos principais.
- **Isso evita o problema do "N+1 queries"** que acontece quando voc√™ acessa relacionamentos em um `loop`, onde para cada objeto principal √© feita uma query extra para buscar o objeto relacionado.

üöÄ **Quando usar `prefetch_related()`**

- Para rela√ß√µes **`ManyToManyField`** (muitos-para-muitos).
- Para relacionamentos reversos via `ForeignKey` (exemplo: acessar todos os livros de um autor a partir do autor).
- Para rela√ß√µes gen√©ricas (GenericRelation).
- Quando o relacionamento √© do lado ‚Äúmuitos‚Äù da rela√ß√£o.

üíª **Exemplo 01**

```python
# Sem otimiza√ß√£o - faz query para cada livro
livros = Livro.objects.all()
for livro in livros:
    print(livro.autores.all())  # Query extra para cada livro

# Com prefetch_related - faz 2 queries totais
livros = Livro.objects.prefetch_related('autores').all()
for livro in livros:
    print(livro.autores.all())  # Sem query extra

# Combinando select_related e prefetch_related
from django.db.models import Prefetch

livros = Livro.objects.select_related(
    'editora'
).prefetch_related(
    'autores',
    'categorias',
    Prefetch(
        'emprestimo_set',
        queryset=Emprestimo.objects.filter(ativo=True)
    )
)
```

üíª **Exemplo 02**

```python
# Sem prefetch_related - uma query para autores e uma query para livros de cada autor (N+1)
autores = Autor.objects.all()
for autor in autores:
    livros = autor.livros.all()  # Query extra para cada autor

# Com prefetch_related - executa 2 queries e junta em Python, evitando N+1
autores = Autor.objects.prefetch_related('livros').all()
for autor in autores:
    livros = autor.livros.all()  # N√£o faz query extra
```

ü§ñ **Benef√≠cios principais**

- Reduz drasticamente o n√∫mero de consultas ao banco em acesso a relacionamentos complexos.
- Melhora o desempenho das aplica√ß√µes, especialmente para rela√ß√µes muitos-para-muitos e acessos reversos.
- Mant√©m a consulta ao banco mais simples e evita o crescimento exponencial de queries.

üì¢ **Cuidados e limita√ß√µes**

- Como faz duas queries, pode n√£o ser ideal se os conjuntos retornados forem muito grandes ou se os dados relacionados forem extremamente pesados.
- N√£o √∫til para ForeignKey direto (usar `select_related()` nesse caso √© mais eficiente).
- Pode ser usado com objetos QuerySet customizados para otimizar ainda mais.

Em resumo, o `prefetch_related()` executa consultas separadas para os dados relacionados e faz a jun√ß√£o em Python, sendo a estrat√©gia ideal para pr√©-carregar dados em relacionamentos muitos-para-muitos e consultas reversas evitando m√∫ltiplas consultas desnecess√°rias ao banco de dados e melhorando o desempenho do Django ORM.

### 12.2. M√©todos `Q` Objects - `Queries` Complexas

Os objetos **Q** no Django s√£o uma ferramenta poderosa para construir consultas complexas e din√¢micas ao banco de dados usando o ORM, permitindo combina√ß√µes flex√≠veis de condi√ß√µes com operadores l√≥gicos.

üö® **O que s√£o os objetos Q?**

- Um objeto Q representa uma express√£o de consulta (filtro) utilizando argumentos nomeados, semelhante aos par√¢metros do m√©todo `filter()`.
- Permite combinar m√∫ltiplas condi√ß√µes usando operadores booleanos para criar filtros mais elaborados do que os filtros padr√£o do ORM.

üöÄ **Operadores principais**

- `&` (AND): combina duas condi√ß√µes onde ambas devem ser verdadeiras.
- `|` (OR): combina duas condi√ß√µes onde pelo menos uma deve ser verdadeira.
- `~` (NOT): nega uma condi√ß√£o, selecionando objetos que **n√£o** atendem ao crit√©rio.

ü§ñ **Por que usar Q objects?**

1. Para efetuar **consultas que requerem OR** ou nega√ß√£o, que n√£o s√£o poss√≠veis com m√∫ltiplos par√¢metros no `filter()` (que faz AND autom√°tico).
2. Para construir consultas din√¢micas, onde os filtros podem mudar durante a execu√ß√£o do programa.
3. Para combinar m√∫ltiplas condi√ß√µes complexas agrupadas, incluindo par√™nteses l√≥gicos.

üíª **Exemplo 01**

```python
from django.db.models import Q

# OR - Qualquer condi√ß√£o satisfeita
livros = Livro.objects.filter(
    Q(titulo__icontains='python') | Q(titulo__icontains='django')
)

# AND - Todas condi√ß√µes devem ser satisfeitas
livros = Livro.objects.filter(
    Q(disponivel=True) & Q(preco__lte=50)
)

# NOT - Nega√ß√£o
livros = Livro.objects.filter(
    Q(disponivel=True) & ~Q(categoria__nome='Terror')
)

# Combina√ß√µes complexas
livros = Livro.objects.filter(
    (Q(titulo__icontains='python') | Q(titulo__icontains='django')) &
    Q(ano_publicacao__gte=2020) &
    ~Q(preco__gt=100)
)

# Queries din√¢micas
def buscar_livros(termo_busca=None, ano_min=None, preco_max=None):
    query = Q()
    
    if termo_busca:
        query &= Q(titulo__icontains=termo_busca) | Q(sinopse__icontains=termo_busca)
    
    if ano_min:
        query &= Q(ano_publicacao__gte=ano_min)
    
    if preco_max:
        query &= Q(preco__lte=preco_max)
    
    return Livro.objects.filter(query)
```

üíª **Exemplo 02**

```python
from django.db.models import Q

# Buscar livros cujo t√≠tulo contenha "Python" OU "Django"
livros = Livro.objects.filter(
    Q(titulo__icontains='python') | Q(titulo__icontains='django')
)

# Buscar livros cujo t√≠tulo contenha "Python" E estejam dispon√≠veis
livros_disponiveis = Livro.objects.filter(
    Q(titulo__icontains='python') & Q(disponivel=True)
)

# Excluir livros cujo t√≠tulo contenha 'Python'
livros_sem_python = Livro.objects.filter(~Q(titulo__icontains='python'))

# Consultas complexas combinando Q com argumentos normais
livros_filtrados = Livro.objects.filter(
    Q(titulo__icontains='python') | Q(titulo__icontains='django'),
    ano_publicacao__gte=2020,
    disponivel=True
)
```

üì¢ **Como funciona internamente**

- Objetos `Q` s√£o combinados em uma estrutura l√≥gica que o `ORM` traduz em uma cl√°usula `WHERE` `SQL` complexa.
- Eles podem ser aninhados, permitindo defini√ß√µes arbitrariamente complexas.
- Voc√™ pode usar m√∫ltiplos objetos `Q` em um mesmo m√©todo de filtro, que por padr√£o s√£o combinados com `AND`.
- Tornam o c√≥digo das queries mais leg√≠vel e expressivo.

Em suma, os m√©todos baseados em objetos **Q** permitem criar consultas **complexas, flex√≠veis e din√¢micas** utilizando l√≥gica booleana, indo muito al√©m das limita√ß√µes naturais do simples uso dos par√¢metros fixos do `filter()` no Django ORM.


### 12.3. M√©todos de Agrega√ß√£o

Os **m√©todos de agrega√ß√£o** no Django ORM s√£o fun√ß√µes especiais usadas para calcular valores agregados diretamente no banco de dados em vez de fazer isso manualmente em Python ap√≥s carregar todos os objetos. Eles realizam opera√ß√µes como soma, m√©dia, contagem, valor m√≠nimo ou m√°ximo sobre os dados de um QuerySet, retornando resultados resumidos ao inv√©s de listas de objetos completos.

üö® **Principais m√©todos de agrega√ß√£o**

- **aggregate()**: Aplica uma ou mais fun√ß√µes de agrega√ß√£o e retorna um dicion√°rio com os resultados.
- **annotate()**: Calcula valores agregados agrupados para cada objeto e adiciona esses valores como atributos extras em cada objeto do QuerySet.

üöÄ **As fun√ß√µes de agrega√ß√£o mais comuns s√£o:**
- **Count**: Conta registros
- **Sum**: Soma os valores de um campo num√©rico
- **Avg**: Calcula a m√©dia de valores num√©ricos
- **Max**: Retorna o maior valor
- **Min**: Retorna o menor valor

Os m√©todos e fun√ß√µes acima s√£o encontrados em `django.db.models`.

#### üóÇÔ∏è **annotate()**

Usamos esse m√©todo quando queremos agregar valores agrupados por cada objeto principal. Por exemplo, contar quantos livros cada editora possui:

```python
from django.db.models import Count
editoras = Editora.objects.annotate(num_livros=Count('livro'))
for editora in editoras:
    print(editora.nome, editora.num_livros)
# Sa√≠da:
# "Companhia das Letras" 22
# "Intr√≠nseca" 15
# "Record" 12
```

Agora, cada inst√¢ncia de Editora recebeu um atributo extra `num_livros` com a contagem de livros associados a ela.

Adiciona campos calculados a cada objeto.

```python
from django.db.models import Count, Avg, Sum, Max, Min

# Contar empr√©stimos por livro
livros = Livro.objects.annotate(
    num_emprestimos=Count('emprestimo')
).filter(num_emprestimos__gt=5)

# M√∫ltiplas anota√ß√µes
livros = Livro.objects.annotate(
    num_emprestimos=Count('emprestimo'),
    media_avaliacoes=Avg('avaliacao__nota'),
    total_vendas=Sum('venda__quantidade')
).order_by('-num_emprestimos')

# Usando em queries
from django.db.models import F

livros = Livro.objects.annotate(
    lucro=F('preco') - F('custo')
).filter(lucro__gt=20)
```

#### üóÇÔ∏è **aggregate()**

Imagina que queremos saber a quantidade total de livros e o pre√ßo m√©dio de todos os livros cadastrados:

```python
from django.db.models import Count, Avg
resultado = Livro.objects.aggregate(
    total_livros=Count('id'),
    preco_medio=Avg('preco')
)
print(resultado)
# Sa√≠da: {'total_livros': 157, 'preco_medio': 42.75}
```
O resultado ser√° um dicion√°rio, onde cada chave representa a opera√ß√£o agregada solicitada.

Calcula valores agregados para todo o QuerySet.

```python
from django.db.models import Count, Avg, Sum, Max, Min

# Estat√≠sticas gerais
stats = Livro.objects.aggregate(
    total_livros=Count('id'),
    preco_medio=Avg('preco'),
    preco_total=Sum('preco'),
    preco_maximo=Max('preco'),
    preco_minimo=Min('preco')
)
# Retorna: {'total_livros': 150, 'preco_medio': 45.50, ...}

# Filtrar antes de agregar
stats_disponiveis = Livro.objects.filter(
    disponivel=True
).aggregate(
    total=Count('id'),
    media_preco=Avg('preco')
)
```


#### üóÇÔ∏è Soma, M√©dia, M√≠nimo, M√°ximo

```python
from django.db.models import Sum, Min, Max

estatisticas = Livro.objects.aggregate(
    paginas_total=Sum('quantidade_paginas'),
    menor_preco=Min('preco'),
    maior_preco=Max('preco')
)
print(estatisticas)
# Sa√≠da: {'paginas_total': 32000, 'menor_preco': 24.90, 'maior_preco': 128.90}
```

#### üóÇÔ∏è Combinando m√©todos

Voc√™ pode filtrar e depois agregar:

```python
from django.db.models import Avg

# M√©dia do pre√ßo s√≥ dos livros publicados ap√≥s 2020
media_preco = Livro.objects.filter(ano_publicacao__gt=2020).aggregate(Avg('preco'))
print(media_preco)
# Sa√≠da: {'preco__avg': 55.43}
```

#### üéØ Por que usar m√©todos de agrega√ß√£o?

- Otimizam o desempenho, pois o c√°lculo √© feito no banco e apenas o resultado final √© trafegado para o Python.
- Usados em relat√≥rios, dashboards, KPIs, gr√°ficos e qualquer situa√ß√£o que precise de contagem, m√©dias, somat√≥rios ou agrupamentos.
- Substituem a necessidade de processar listas enormes de dados em Python.


### 12.4. M√©todos que Retornam Valores

Os **m√©todos que retornam valores** no Django ORM s√£o fun√ß√µes que executam uma consulta no banco e retornam diretamente valores espec√≠ficos ao inv√©s de retornar um conjunto (QuerySet) de objetos completos. Eles s√£o usados para obter informa√ß√µes simples e diretas, como um √∫nico objeto, um valor agregado, uma contagem, ou um subconjunto de dados, facilitando consultas espec√≠ficas e uso eficiente dos dados.

#### üî§ **get()**

Retorna exatamente um √∫nico objeto que corresponda aos crit√©rios informados.

```python
# Buscar por PK
livro = Livro.objects.get(pk=1)

# Buscar por outros campos
livro = Livro.objects.get(isbn='9788535902771')

# Levanta exce√ß√£o se n√£o encontrar ou se encontrar m√∫ltiplos
try:
    livro = Livro.objects.get(titulo="Django")
except Livro.DoesNotExist:
    print("Livro n√£o encontrado")
except Livro.MultipleObjectsReturned:
    print("M√∫ltiplos livros encontrados")
```

- Levanta exce√ß√£o se nenhum ou mais de um objeto for encontrado.
- Deve ser usado apenas quando voc√™ tem certeza que existe um √∫nico resultado.

#### üî§ **first() e last()**
Retorna o primeiro ou √∫ltimo objeto.

```python
primeiro = Livro.objects.order_by('ano_publicacao').first()
ultimo = Livro.objects.order_by('ano_publicacao').last()

# Retorna None se n√£o houver resultados
mais_recente = Livro.objects.filter(disponivel=True).last()
```

- Retornam `None` se n√£o houver nenhum objeto.

#### üî§ **count()**
Retorna a quantidade total de objetos no QuerySet.

```python
total = Livro.objects.count()
disponiveis = Livro.objects.filter(disponivel=True).count()
```

- Eficiente para verificar quantos registros existem sem carregar os objetos.

#### üî§ **exists()**

Retorna `True` se o QuerySet cont√©m pelo menos um objeto, sen√£o `False`.

```python
tem_livros = Livro.objects.filter(disponivel=True).exists()

if Livro.objects.filter(isbn=isbn_buscado).exists():
    print("ISBN j√° cadastrado")
```

- √ötil para verificar a exist√™ncia sem precisar carregar objetos.

#### üî§ **values() e values_list()**

Retornam listas de dicion√°rios (`values()`) ou tuplas (`values_list()`) com os campos solicitados, ao inv√©s de inst√¢ncias do modelo.

```python
# values() - retorna dicion√°rios
livros = Livro.objects.values('id', 'titulo', 'preco')
# [{'id': 1, 'titulo': 'Django', 'preco': 50.00}, ...]

# values_list() - retorna tuplas
livros = Livro.objects.values_list('titulo', 'preco')
# [('Django', 50.00), ('Python', 45.00), ...]

# values_list com flat=True - retorna lista simples (apenas 1 campo)
titulos = Livro.objects.values_list('titulo', flat=True)
# ['Django', 'Python', ...]
```

- √ötil para extrair somente os dados necess√°rios e melhorar desempenho.

#### üíª Exemplos 

```python
# get() - busca √∫nico livro
try:
    livro = Livro.objects.get(pk=1)
except Livro.DoesNotExist:
    print("Livro n√£o encontrado")
except Livro.MultipleObjectsReturned:
    print("Mais de um livro encontrado")

# first() - primeiro livro mais barato
livro_barato = Livro.objects.order_by('preco').first()

# count() - n√∫mero total de livros dispon√≠veis
num_disponiveis = Livro.objects.filter(disponivel=True).count()

# exists() - verifica se h√° livros de determinado autor
existe_low = Livro.objects.filter(autor__nome="Low").exists()

# values() - retorna t√≠tulos e pre√ßos para exibi√ß√£o em relat√≥rio
relatorio = Livro.objects.filter(disponivel=True).values('titulo', 'preco')
for item in relatorio:
    print(item['titulo'], item['preco'])
```

ü§ñ **Por que usar esses m√©todos?**

- Obtemos exatamente o que precisamos de forma direta, sem carregar objetos completos quando n√£o necess√°rio.
- Melhora o desempenho evitando carregamento desnecess√°rio de dados.
- Facilita implementa√ß√µes para verifica√ß√µes r√°pidas, buscas √∫nicas, contagens e extra√ß√£o de informa√ß√µes resumidas.


Em resumo, os m√©todos que retornam valores no Django ORM s√£o √∫teis para obter **dados espec√≠ficos e simples** de forma eficiente, ajudando a economizar recursos e tornando o c√≥digo mais claro e focado.


### 12.5. M√©todos de Cria√ß√£o e Atualiza√ß√£o

Os **M√©todos de Cria√ß√£o e Atualiza√ß√£o** no Django `ORM` s√£o fun√ß√µes que permitem criar novos objetos diretamente no banco de dados ou atualizar objetos existentes usando uma interface simples e eficiente, sem precisar manipular explicitamente comandos `SQL`.

üöÄ **Por que usar esses m√©todos?**

- Facilitam manipula√ß√£o de dados no banco de forma simples e intuitiva.
- Permitem opera√ß√µes em lote para maior efici√™ncia.
- Tratam automaticamente detalhes como SQL, rollback, sincroniza√ß√£o de cache.
- Integrados com o ciclo de vida dos objetos, incluindo sinais do Django.

Em resumo, os m√©todos de cria√ß√£o e atualiza√ß√£o do Django ORM fornecem formas eficientes e pr√°ticas para inserir, alterar e remover dados no banco diretamente do c√≥digo Python, simplificando o desenvolvimento e otimizando o acesso √† base de dados.

#### ‚úíÔ∏è **create()**

Cria e salva um novo objeto em uma √∫nica opera√ß√£o simplificando a inser√ß√£o.


```python
livro = Livro.objects.create(
    titulo="Django para Iniciantes",
    ano_publicacao=2023,
    preco=45.90,
    disponivel=True
)
```

Este m√©todo cria a inst√¢ncia e j√° realiza o insert no banco.

#### ‚úíÔ∏è **get_or_create()**

Busca um objeto que corresponde aos crit√©rios; se n√£o existir, cria um novo.

```python
livro, criado = Livro.objects.get_or_create(
    isbn='9788535902771',
    defaults={
        'titulo': 'Python Fluente',
        'ano_publicacao': 2015,
        'preco': 89.90
    }
)

if criado:
    print("Novo livro criado")
else:
    print("Livro j√° existia")
```

- √ötil para evitar duplica√ß√µes e garantir unicidade.

#### ‚úíÔ∏è **update_or_create()**

Atualiza um objeto existente ou cria um novo, caso n√£o exista.

```python
livro, criado = Livro.objects.update_or_create(
    isbn='9788535902771',
    defaults={
        'titulo': 'Python Fluente - 2¬™ Ed',
        'preco': 99.90
    }
)
```

- Facilita manter dados sincronizados sem m√∫ltiplas consultas.

#### ‚úíÔ∏è **update()**

Atualiza m√∫ltiplos objetos que correspondam a um filtro, sem recuperar os objetos no Python.

```python
# Atualizar m√∫ltiplos registros
Livro.objects.filter(ano_publicacao__lt=2020).update(
    disponivel=False
)

# Usando express√µes F
from django.db.models import F
Livro.objects.filter(
    exemplares_disponiveis__gt=0
).update(
    exemplares_disponiveis=F('exemplares_disponiveis') - 1
)
```

- Efetua um comando SQL `UPDATE` diretamente.
- Pode usar express√µes `F()` para atualizar valores relativos.

#### ‚úíÔ∏è **bulk_create()**

Cria v√°rias inst√¢ncias em lote, aumentando a performance.

```python
livros = [
    Livro(titulo="Livro 1", preco=30),
    Livro(titulo="Livro 2", preco=40),
    Livro(titulo="Livro 3", preco=50),
]

Livro.objects.bulk_create(livros)
```

- Ideal para inserir grande volume de dados rapidamente.
- N√£o chama sinais (`signals`) nem executa valida√ß√£o dos objetos.

#### ‚úíÔ∏è **delete()**

Apaga objetos do banco.

```python
# Deletar um objeto
livro = Livro.objects.get(pk=1)
livro.delete()

# Deletar m√∫ltiplos objetos
Livro.objects.filter(disponivel=False).delete()

# Deletar todos
Livro.objects.all().delete()
```
