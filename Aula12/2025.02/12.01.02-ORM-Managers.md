# Django ORM: Managers üèóÔ∏è

O Django ORM (`Object-Relational Mapper`) √© uma das ferramentas mais poderosas do framework Django. Ele permite que voc√™ **interaja com o banco de dados usando c√≥digo Python** orientado a objetos, **sem necessidade de escrever SQL diretamente**. O ORM traduz suas **classes Python em tabelas de banco de dados** e suas opera√ß√µes em Python para queries SQL.

Para contextualizar os conceitos que vamos aprender, vamos desenvolver uma aplica√ß√£o de **gest√£o de biblioteca**, que inclui modelos para livros, autores, editoras, empr√©stimos e usu√°rios.

## 11. `Managers` - Gerenciadores de Objetos üöá

O `Manager` √© a **interface** atrav√©s da qual as opera√ß√µes de **consulta ao banco de dados** s√£o disponibilizadas para os modelos Django. Cada modelo tem pelo menos um Manager, acess√≠vel atrav√©s de `objects`.

### 11.1. Manager Padr√£o

O **Manager Padr√£o** no Django ORM √© o gerenciador de objetos que o Django cria automaticamente para cada modelo, chamado pelo nome padr√£o **`objects`**. Ele √© a interface principal atrav√©s da qual voc√™ realiza opera√ß√µes de consulta e manipula√ß√£o dos dados no banco para aquele modelo.

**Fun√ß√£o do Manager Padr√£o**
- Fornece m√©todos para acessar e manipular o conjunto de objetos daquele modelo, como `all()`, `filter()`, `get()`, `create()`, `update()`, `delete()`.
- Retorna objetos do tipo **QuerySet**, que representam consultas ao banco de dados e permitem filtrar, ordenar, agregar e executar opera√ß√µes complexas.
- Sustenta a comunica√ß√£o entre seu c√≥digo Python e o banco de dados, encapsulando a gera√ß√£o e execu√ß√£o das queries SQL.

```python
class Livro(models.Model):
    titulo = models.CharField(max_length=200)
    disponivel = models.BooleanField(default=True)
    
    # Manager padr√£o (criado automaticamente)
    objects = models.Manager()

# Uso:
todos_livros = Livro.objects.all()
livro = Livro.objects.get(pk=1)
livros_filtrados = Livro.objects.filter(titulo__icontains="python")
```

### 11.2. Managers Customizados

#### 11.2.1. Criando um Manager Simples

Para criar um **Manager customizado simples** no Django, voc√™ deve criar uma subclasse de `models.Manager` e adicionar m√©todos que implementem a l√≥gica personalizada desejada. Depois, basta atribuir essa classe ao atributo `objects` (ou outro nome) do seu modelo para substituir ou adicionar um gerenciador de objetos.

**Como fazer passo a passo**

1. Crie uma classe herdando de `models.Manager`.
2. Defina dentro dela m√©todos que retornem `QuerySets` filtrados ou fa√ßam opera√ß√µes espec√≠ficas.
3. No modelo, atribua um objeto dessa classe √† propriedade `objects` (ou outro nome de manager desejado).
4. Use os m√©todos customizados para consultas especializadas.


```python
class LivroDisponivelManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(disponivel=True)

class Livro(models.Model):
    titulo = models.CharField(max_length=200)
    disponivel = models.BooleanField(default=True)
    
    # Manager padr√£o
    objects = models.Manager()
    
    # Manager customizado
    disponiveis = LivroDisponivelManager()

# Uso:
todos = Livro.objects.all()  # Todos os livros
apenas_disponiveis = Livro.disponiveis.all()  # Apenas dispon√≠veis
```

**Explica√ß√µes importantes:**

- O m√©todo `get_queryset()` define o queryset base retornado pelo manager.
- `super().get_queryset()` chama o queryset padr√£o que √© ent√£o filtrado.
- Pode-se ter v√°rios managers, mas o padr√£o `objects` √© sempre recomendado manter.
- Utilizar managers customizados ajuda a organizar melhor as consultas comuns e torna o c√≥digo mais limpo e leg√≠vel.


#### 11.2.2. Manager com M√©todos Customizados

Um **Manager com M√©todos Customizados** no Django √© um gerenciador de objetos onde voc√™ define m√©todos adicionais para implementar consultas espec√≠ficas, encapsular l√≥gica reutiliz√°vel e facilitar o acesso a conjuntos filtrados de registros.

**Como criar um Manager com m√©todos customizados**

1. Crie uma classe que herde de `models.Manager`.
2. Defina dentro dessa classe m√©todos que retornem QuerySets ou outras opera√ß√µes que voc√™ deseja reutilizar.
3. Atribua o Manager customizado ao seu modelo, geralmente substituindo ou complementando o atributo padr√£o `objects`.

```python
from django.db import models
from django.db.models import Count

class LivroManager(models.Manager):
    def disponiveis(self):
        """Retorna apenas livros dispon√≠veis"""
        return self.filter(disponivel=True)
    
    def por_editora(self, editora):
        """Filtra livros por editora"""
        return self.filter(editora=editora)
    
    def publicados_apos(self, ano):
        """Livros publicados ap√≥s determinado ano"""
        return self.filter(ano_publicacao__gte=ano)
    
    def mais_emprestados(self, limite=10):
        """Retorna os livros mais emprestados"""
        from django.db.models import Count
        return self.annotate(
            num_emprestimos=Count('emprestimo')
        ).order_by('-num_emprestimos')[:limite]

class Livro(models.Model):
    titulo = models.CharField(max_length=200)
    disponivel = models.BooleanField(default=True)
    editora = models.ForeignKey(Editora, on_delete=models.CASCADE)
    ano_publicacao = models.PositiveIntegerField()
    
    objects = LivroManager()

# Uso:
livros_disponiveis = Livro.objects.disponiveis()
livros_da_editora = Livro.objects.por_editora(editora_objeto)
livros_2023 = Livro.objects.publicados_apos(2023)
top_10 = Livro.objects.mais_emprestados(10)

# Encadeamento de m√©todos
livros_filtrados = Livro.objects.disponiveis().por_editora(editora).publicados_apos(2020)
```

**Benef√≠cios**

- Facilita a reutiliza√ß√£o de consultas frequentes.
- Mant√©m o c√≥digo organizado e limpo, separando a l√≥gica de consulta do restante da aplica√ß√£o.
- Permite a cria√ß√£o de m√©todos expressivos que facilitam a leitura e manuten√ß√£o do c√≥digo.


### 11.3. Combinando Manager e QuerySet Customizados

A melhor abordagem moderna para criar Managers customizados no Django √© usar os m√©todos **`QuerySet.as_manager()`** ou **`Manager.from_queryset()`** porque eles permitem que voc√™ escreva seus m√©todos de consulta uma √∫nica vez dentro de uma subclasse de `QuerySet` e ent√£o expor esses m√©todos tanto no QuerySet quanto no Manager, evitando duplica√ß√£o de c√≥digo e facilitando o encadeamento de consultas.

**Por que usar `QuerySet.as_manager()` ou `Manager.from_queryset()`?**

- Um **QuerySet** representa uma cole√ß√£o de objetos que podem ser filtrados, ordenados, anotados, etc. Um **Manager** √© a interface que retorna esses QuerySets e fornece m√©todos para acess√°-los.
- Se voc√™ cria m√©todos customizados somente no Manager, esses m√©todos n√£o ficam dispon√≠veis para encadeamento em QuerySets intermedi√°rios.
- Se cria m√©todos somente no QuerySet, eles ficam dispon√≠veis ao trabalhar com QuerySets, mas n√£o diretamente no Manager.
- Usando `QuerySet.as_manager()`, voc√™ transforma sua classe de QuerySet em um Manager que possui automaticamente todos os m√©todos customizados definidos no QuerySet.
- Com `Manager.from_queryset()`, voc√™ pode criar um Manager que estenda um QuerySet customizado, permitindo tamb√©m adicionar m√©todos somente no Manager se desejar.

**Benef√≠cios principais**

- **Evita duplica√ß√£o de c√≥digo**: voc√™ n√£o precisa definir os mesmos m√©todos tanto no QuerySet quanto no Manager.
- **Facilita o encadeamento de m√©todos**: voc√™ pode encadear v√°rios filtros e customiza√ß√µes fluentemente.
- **Separa√ß√£o clara das responsabilidades**: QuerySet para consultas e Manager para acesso inicial e m√©todos exclusivos de gerenciamento.
- **Compatibilidade e clareza**: seguindo esta abordagem, seu c√≥digo fica mais f√°cil de entender, manter e reutilizar.


**Exemplo simples usando `as_manager()`**

```python


class LivroQuerySet(models.QuerySet):
    def disponiveis(self):
        return self.filter(disponivel=True)
    
    def publicados_apos(self, ano):
        return self.filter(ano_publicacao__gte=ano)

class Livro(models.Model):
    titulo = models.CharField(max_length=200)
    disponivel = models.BooleanField(default=True)
    ano_publicacao = models.PositiveIntegerField()
    
    objects = LivroQuerySet.as_manager()

# Uso:
livros = Livro.objects.disponiveis().publicados_apos(2020)
```

**Exemplo com `from_queryset()`**

```python
class LivroQuerySet(models.QuerySet):
    def disponiveis(self):
        return self.filter(disponivel=True)

class LivroManager(models.Manager):
    def criar_livro_especial(self, titulo):
        return self.create(titulo=titulo, disponivel=True)

Livro.objects = LivroManager.from_queryset(LivroQuerySet)()

# Usa m√©todos do manager e do queryset
livros = Livro.objects.disponiveis()
livro_especial = Livro.objects.criar_livro_especial("Django Avan√ßado")
```

**Exemplo completo**

```python
from django.db import models

class LivroQuerySet(models.QuerySet):
    def disponiveis(self):
        return self.filter(disponivel=True)
    
    def por_categoria(self, categoria):
        return self.filter(categorias=categoria)
    
    def publicados_entre(self, ano_inicial, ano_final):
        return self.filter(
            ano_publicacao__gte=ano_inicial,
            ano_publicacao__lte=ano_final
        )
    
    def com_estoque(self):
        return self.filter(exemplares_disponiveis__gt=0)

# M√©todo 1: Usar QuerySet como Manager
class Livro(models.Model):
    titulo = models.CharField(max_length=200)
    disponivel = models.BooleanField(default=True)
    exemplares_disponiveis = models.PositiveIntegerField(default=0)
    
    objects = LivroQuerySet.as_manager()

# M√©todo 2: Combinar Manager customizado com QuerySet
class LivroManager(models.Manager):
    def criar_com_codigo(self, titulo, **kwargs):
        """M√©todo espec√≠fico do Manager"""
        codigo = f"LIV-{uuid.uuid4().hex[:8]}"
        return self.create(titulo=titulo, codigo=codigo, **kwargs)

class Livro(models.Model):
    titulo = models.CharField(max_length=200)
    codigo = models.CharField(max_length=12, unique=True)
    
    objects = LivroManager.from_queryset(LivroQuerySet)()

# Uso combinado:
# M√©todos do QuerySet funcionam normalmente
livros = Livro.objects.disponiveis().por_categoria(categoria)

# M√©todos do Manager tamb√©m funcionam
livro = Livro.objects.criar_com_codigo("Novo Livro")

# Encadeamento complexo
resultado = (Livro.objects
    .disponiveis()
    .com_estoque()
    .publicados_entre(2020, 2023)
    .order_by('-ano_publicacao'))
```
