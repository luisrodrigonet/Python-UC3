# 12.01.04 - ORM - MongoDB no Django

Este guia aborda a biblioteca que torna essa integra√ß√£o poss√≠vel, como configurar seu projeto, e o mais importante: os campos suportados e suas propriedades, com foco nas funcionalidades espec√≠ficas que o MongoDB oferece.

### üêò MongoDB com Django

Muitos desenvolvedores que amam a produtividade do Django se perguntam se √© poss√≠vel trocar o tradicional banco de dados SQL (como PostgreSQL ou SQLite) pela flexibilidade e escalabilidade de um banco de dados NoSQL como o MongoDB. A resposta √© **sim**, e este guia mostrar√° como.

O ORM (Mapeador Objeto-Relacional) nativo do Django foi projetado especificamente para se comunicar com bancos de dados SQL. Ele n√£o "fala a l√≠ngua" do MongoDB nativamente.

√â aqui que entra uma biblioteca de terceiros chamada **Djongo**, que atua como um "tradutor" inteligente, permitindo que voc√™ escreva o c√≥digo Python que j√° conhece (Models, QuerySets) e o converte, por debaixo dos panos, para as consultas e estruturas de documentos que o MongoDB entende.

Com Djongo, voc√™ obt√©m o melhor dos dois mundos:

* A **produtividade e a estrutura** do Django, incluindo seu fant√°stico painel de Administra√ß√£o.
* A **flexibilidade de esquema, performance e escalabilidade** do MongoDB.

#### üöÄ Configurando o Ambiente

Integrar o Djongo ao seu projeto Django √© um processo simples.

**1. Instala√ß√£o:**
Primeiro, instale a biblioteca **`djongo`** usando pip.

```bash
pip install djongo
```

**2. Configura√ß√£o do `settings.py`:**

Em seguida, modifique o dicion√°rio **`DATABASES`** no seu arquivo **`settings.py`**. Em vez da configura√ß√£o padr√£o do SQLite, voc√™ usar√° a seguinte estrutura:

```python
# settings.py

DATABASES = {
    'default': {
        'ENGINE': 'djongo',
        'NAME': 'o_nome_do_seu_banco',      # <--  O nome do banco de dados no MongoDB
        'ENFORCE_SCHEMA': False,            # <-- Permite a flexibilidade do NoSQL
        'CLIENT': {
            'host': 'mongodb+srv://<username>:<password>@seu-cluster.mongodb.net/',
            'port': 27017,
            'username': 'seu_usuario_aqui',
            'password': 'sua_senha_aqui',
            'authMechanism': 'SCRAM-SHA-1'
        }
    }
}
```

* **`ENGINE`**: Deve ser `'djongo'`.

* **`NAME`**: O nome do banco de dados que ser√° criado ou utilizado no MongoDB.

* **`ENFORCE_SCHEMA`**: Definir como `False` √© crucial para aproveitar a natureza sem esquema (schema-less) do MongoDB, permitindo que documentos na mesma cole√ß√£o tenham campos diferentes.

* **`CLIENT`**: Cont√©m os detalhes da sua conex√£o. O `host` pode ser uma string de conex√£o do MongoDB Atlas ou o endere√ßo do seu servidor local (ex: `mongodb://localhost:27017`).

Feito isso, voc√™ j√° pode executar **`python manage.py migrate`** e o Djongo cuidar√° de criar as cole√ß√µes necess√°rias no MongoDB.

#### üß© Dicion√°rio de Campos: Django + Djongo

Aqui vem a parte mais interessante. Voc√™ definir√° seus modelos no arquivo `models.py` de forma muito similar √† tradicional, mas com superpoderes NoSQL.

##### Campos Padr√£o do Django

A grande maioria dos campos padr√£o do Django funciona perfeitamente com o Djongo. Eles s√£o mapeados para tipos de dados BSON equivalentes no MongoDB.

| Campo Django | Tipo BSON no MongoDB | Propriedades Comuns Suportadas |
| :--- | :--- | :--- |
| `CharField` | `String` | `max_length`, `default`, `null`, `blank` |
| `TextField` | `String` | `default`, `null`, `blank` |
| `IntegerField` | `Int32 / Int64` | `default`, `null`, `blank` |
| `FloatField` | `Double` | `default`, `null`, `blank` |
| `DecimalField` | `Decimal128` | `max_digits`, `decimal_places` |
| `BooleanField` | `Boolean` | `default`, `null` |
| `DateField` | `Date` | `auto_now`, `auto_now_add`, `default` |
| `DateTimeField` | `Date` | `auto_now`, `auto_now_add`, `default` |
| `EmailField`, `URLField` | `String` | `max_length`, `default`, `null`, `blank` |
| `UUIDField` | `UUID` | `primary_key`, `default` |

**Propriedades comuns** como **`verbose_name`**, **`help_text`**, **`unique`**, **`db_index`**, e **`choices`** tamb√©m s√£o suportadas normalmente.

##### Campos Espec√≠ficos do Djongo

Djongo introduz novos campos no `djongo.models` para que voc√™ possa modelar seus dados de uma forma que aproveite a estrutura de documentos do MongoDB.

**1. `EmbeddedField`**
Este √© o campo mais importante. Ele permite que voc√™ aninhe (`embedde`) um modelo dentro de outro, um conceito central do NoSQL que evita a necessidade de "`joins`".

  * **Propriedades Suportadas:**
      * `model_container`: **Obrigat√≥rio.** Aponta para a classe do modelo que ser√° embutida.
      
      * `model_form_class`: Opcional. Permite especificar um `ModelForm` customizado para renderizar este campo no Django Admin.
      
      * `null`, `blank`, `default`: Funcionam como nos campos padr√£o.

**2. `ArrayField`**

Permite armazenar uma lista de valores dentro de um √∫nico campo. Isso √© incrivelmente √∫til para coisas como tags, m√∫ltiplos n√∫meros de telefone, etc.

  * **Propriedades Suportadas:**
  
      * O primeiro argumento do campo define o tipo de dado que a lista ir√° conter. Pode ser um campo padr√£o do Django (como `models.CharField`) ou um `EmbeddedField` para criar uma lista de documentos aninhados.
      * `default`, `null`, `blank`.

#### üß± Exemplo Pr√°tico de Modelagem NoSQL

Vamos criar um modelo para um Blog. Em SQL, precisar√≠amos de tabelas separadas para `Post`, `Autor` e `Comentario` com chaves estrangeiras. Com Djongo, podemos modelar de uma forma muito mais natural e eficiente.

```python
# minha_app/models.py
from djongo import models

# Este modelo n√£o cria uma cole√ß√£o. Ele servir√° para ser embutido.
class Autor(models.Model):
    nome = models.CharField(max_length=100)
    email = models.EmailField()

    class Meta:
        abstract = True # Importante! Diz ao Django para n√£o criar uma tabela/cole√ß√£o para este modelo.

class Comentario(models.Model):
    texto = models.TextField()
    autor = models.EmbeddedField(
        model_container=Autor
    )
    data_criacao = models.DateTimeField(auto_now_add=True)

    class Meta:
        abstract = True

class Post(models.Model):
    _id = models.ObjectIdField() # Chave prim√°ria nativa do MongoDB
    titulo = models.CharField(max_length=200)
    conteudo = models.TextField()
    
    autor_principal = models.EmbeddedField(
        model_container=Autor
    )
    
    tags = models.ArrayField(
        models.CharField(max_length=50)
    )
    
    comentarios = models.ArrayField(
        model_container=Comentario,
        blank=True
    )
    
    data_publicacao = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.titulo
```

**An√°lise do Exemplo:**

* Cada `Post` agora √© um **documento completo e autocontido**. Ele tem seu autor, uma lista de **tags** e uma lista de **coment√°rios**, tudo dentro do mesmo documento no MongoDB.

* `Autor` e `Comentario` s√£o definidos como modelos, mas com `class Meta: abstract = True`. Isso os torna "moldes" reutiliz√°veis para os `EmbeddedField`.

* Usamos `models.ObjectIdField()` para a chave prim√°ria, que √© o tipo nativo do MongoDB.

#### ‚öôÔ∏è Consultas: O ORM do Django em A√ß√£o

O mais impressionante √© que voc√™ continua usando a sintaxe de consulta do Django que j√° conhece, inclusive para consultar dados dentro de campos embutidos ou arrays.

```python
# Criando um post
autor_info = Autor(nome='Ana Silva', email='ana@exemplo.com')

Post.objects.create(
    titulo='Meu Primeiro Post NoSQL',
    conteudo='Este √© um teste...',
    autor_principal=autor_info,
    tags=['django', 'mongodb', 'djongo']
)

# Buscando todos os posts
todos_os_posts = Post.objects.all()

# Filtrando por um campo em um documento embutido!
posts_da_ana = Post.objects.filter(autor_principal__nome='Ana Silva')

# Filtrando por um item em um ArrayField
posts_sobre_django = Post.objects.filter(tags__icontains='django')
```

#### ‚úÖ Conclus√£o: O Melhor de Dois Mundos

Usar Djongo para integrar MongoDB com Django oferece uma solu√ß√£o poderosa, unindo a estrutura e ecossistema do Django com a flexibilidade do MongoDB. √â a escolha ideal para projetos que lidam com dados semiestruturados, que precisam de alta velocidade de escrita e leitura, ou que se beneficiam de um modelo de dados mais din√¢mico e evolutivo, sem abrir m√£o da produtividade do `framework`.