# 12.02.02 : üìá ORM - Modelagem do projeto CORE

### üëã Introdu√ß√£o: A Base de Tudo - O Banco de Dados

Imagine que voc√™ est√° construindo uma casa. Antes de colocar o primeiro tijolo, voc√™ precisa da planta baixa, certo? A planta define onde ficar√£o os quartos, a cozinha, os banheiros, etc.

No mundo do desenvolvimento web, o **banco de dados** √© a funda√ß√£o da nossa "casa digital", e a **modelagem de dados** √© a nossa planta baixa. √â o processo onde definimos quais informa√ß√µes vamos guardar e como elas se relacionam entre si.

üéØ **Como o Django facilita nossa vida?**

Em vez de escrevermos comandos complexos de banco de dados (**`SQL`**) diretamente, o Django nos oferece o **`ORM`** (Mapeador Objeto-Relacional). Com ele, n√≥s descrevemos a estrutura do nosso banco de dados usando classes em Python, que s√£o chamadas de **Models**.

O Django se encarrega de traduzir essas classes em Python para tabelas no banco de dados. Simples assim\!

Vamos ent√£o criar a "planta baixa" (os Models) para nossas duas aplica√ß√µes.

## üì¶ Modelando a Aplica√ß√£o **`produtos`**

Esta aplica√ß√£o √© para uso interno, o centro de controle do seu estoque. O objetivo aqui √© gerenciar os produtos. Para isso, precisamos de um lugar para guardar todas as informa√ß√µes de cada item da loja.

Agora, al√©m de gerenciar os produtos, vamos organiz√°-los em categorias e ter um controle r√°pido para ativar ou desativar sua exibi√ß√£o na loja.

#### üé≤ Modelo: **`Categoria`**

Para organizar os produtos (ex: "Camisetas", "Canecas", "Acess√≥rios"), criamos um modelo espec√≠fico para as categorias.

```python
# produtos/models.py (Adicione este modelo no in√≠cio do arquivo)

from django.db import models

class Categoria(models.Model):
    nome = models.CharField(max_length=50, unique=True)
    
    def __str__(self):
        return self.nome

    class Meta:
        verbose_name = "Categoria"
        verbose_name_plural = "Categorias"
```

üö® **Por que um modelo novo?** 
- Separar as categorias nos permite gerenci√°-las de forma independente, al√©m de garantir que n√£o haja nomes duplicados (`unique=True`).

#### üé≤ Modelo **`Produto`** 

Agora, vamos atualizar o modelo **`Produto`** para incluir a liga√ß√£o com a **`Categoria`** e o novo campo **`disponivel`**.

Para cada produto, o que precisamos saber?

  * **Nome:** O t√≠tulo do produto (ex: "Camiseta Estampada Gato").
  * **Descri√ß√£o:** Um texto mais longo detalhando o produto.
  * **Pre√ßo:** O valor de venda.
  * **Estoque:** Quantas unidades temos dispon√≠veis.
  * **Imagem:** Uma foto para exibir no site.
  * **Datas de Controle:** Quando o produto foi criado e atualizado.


üìù **C√≥digo completo para `produtos/models.py`:**

```python
# produtos/models.py

from django.db import models

# Modelo de Categoria
class Categoria(models.Model):
    nome = models.CharField(max_length=50, unique=True)
    
    def __str__(self):
        return self.nome

    class Meta:
        verbose_name = "Categoria"
        verbose_name_plural = "Categorias"

# Modelo Produto
class Produto(models.Model):
    nome = models.CharField(
        max_length=100, 
        help_text="Nome do produto"
        )
    
    descricao = models.TextField(
        help_text="Descri√ß√£o detalhada do produto"
        )
    
    preco = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="Pre√ßo de venda do produto"
    )
    
    estoque = models.PositiveIntegerField(
        default=0, 
        help_text="Quantidade do produto em estoque"
    )

    disponivel = models.BooleanField(
        default=True, 
        help_text="Indica se o produto est√° dispon√≠vel para venda"
    )
    
    imagem = models.ImageField(
        upload_to='produtos/', 
        blank=True, 
        null=True, 
        help_text="Imagem de exibi√ß√£o do produto"
    )

    # Campos de data
    data_criacao = models.DateTimeField(auto_now_add=True)
    data_atualizacao = models.DateTimeField(auto_now=True)
   
    # Aqui est√° a rela√ß√£o! Cada produto pertence a uma categoria. (Aula 11.02.02)
    category = models.ForeignKey(
        Category,
        on_delete=models.SET_NULL,
        null=True,  # <-- Permite que o valor no banco de dados seja NULO
        blank=True, # <-- Permite que o campo no admin/formul√°rios fique em branco 
        related_name="produtos")
    
    def __str__(self):
        return self.nome

    class Meta:
        verbose_name = "Produto"
        verbose_name_plural = "Produtos"
        ordering = ['nome']

```

üö® **Observa√ß√µes:**

1. `models.CharField`: Para textos curtos, como o nome. `max_length` √© obrigat√≥rio.

1. `models.TextField`: Para textos longos, como a descri√ß√£o.

1. `models.DecimalField`: **Essencial para dinheiro\!** Usar `FloatField` pode causar erros de arredondamento. `max_digits` √© o total de d√≠gitos e `decimal_places` s√£o as casas decimais.

1. `models.PositiveIntegerField`: Para n√∫meros inteiros que n√£o podem ser negativos, perfeito para estoque.

1. `models.ImageField`: Para fazer upload de imagens. `upload_to='produtos/'` diz ao Django para salvar as imagens na pasta `media/produtos/`. `blank=True, null=True` torna a imagem opcional.

1. `models.DateTimeField`: Para datas e horas.
    * `auto_now_add=True`: Salva a data e hora apenas na cria√ß√£o do registro.
    * `auto_now=True`: Atualiza a data e hora toda vez que o registro √© salvo.

1. `def __str__(self):`: Este m√©todo √© muito √∫til\! Ele define como o objeto ser√° exibido, por exemplo, na √°rea administrativa do Django. Aqui, ele mostrar√° o nome do produto.

1. `class Meta`: Permite adicionar configura√ß√µes extras ao modelo, como o nome de exibi√ß√£o (`verbose_name`) e a ordena√ß√£o padr√£o (`ordering`).

1.  **`disponivel = models.BooleanField(default=True)`**: 
    -  Adicionamos o campo para controlar a disponibilidade. `default=True` significa que todo novo produto j√° come√ßa como "dispon√≠vel". 
    
    - Com este campo, podemos facilmente filtrar na nossa loja e mostrar apenas os produtos que est√£o √† venda.
    
2.  **`categoria = models.ForeignKey(Categoria, ...)`**: 

    - Criamos a rela√ß√£o. Cada produto agora aponta para uma categoria.
    
      * **`on_delete=models.SET_NULL`**: Esta √© uma regra de exclus√£o interessante. Se uma categoria for apagada, o campo **`categoria`** nos produtos associados ser√° definido como **`NULL`** (vazio), em vez de apagar o produto. Isso preserva seus produtos, que podem depois ser associados a outra categoria. Para isso funcionar, `null=True` √© obrigat√≥rio.
      
      
> **Nota:** O registro de vendas ser√° feito na aplica√ß√£o `site_loja`, pois a venda (ou compra, do ponto de vista do cliente) √© uma a√ß√£o que o cliente realiza no site. A equipe interna usar√° os dados gerados l√° para seus relat√≥rios. Isso mant√©m o sistema mais organizado.


### üõí Modelando a Aplica√ß√£o **`site_loja`**

Esta √© a parte do projeto que seus clientes ver√£o e com a qual ir√£o interagir. Precisamos modelar o formul√°rio de contato, os coment√°rios, os perfis de usu√°rio e, claro, o sistema de compras.

Na aplica√ß√£o do cliente, vamos adicionar a capacidade de os usu√°rios terem um perfil customizado, com foto e tudo mais.


#### Importando as bibliotecas e Models

```python
# site_loja/models.py (in√≠cio do arquivo)

from django.db import models
from django.contrib.auth.models import User

# Importando o modelo Produto da outra aplica√ß√£o
from produtos.models import Produto
```

#### üë§ O Modelo `Contato`

Este modelo ser√° utilizado para guardar as mensagens enviadas pelo formul√°rio de contato do site.

```python
class ContactRequest(models.Model):
    nome = models.CharField(
        max_length=150, 
        verbose_name="Nome"
        )
    
    email = models.EmailField(
        verbose_name="E-mail"
        )
    
    assunto = models.CharField(
        max_length=150,
        default='Sem assunto', 
        blank=True 
        )
    
    mensagem = models.TextField(
        verbose_name="Mensagem"
        )
    
    # Campos de data
    data_criacao = models.DateTimeField(
        auto_now_add=True
        )
    
    data_atualizacao = models.DateTimeField(
        auto_now=True, 
        verbose_name="Enviado em"
        )
    
    lido = models.BooleanField(
        default=False, 
        help_text="Marca se a mensagem foi lida"
        )

    def __str__(self):
        return f"{self.nome} - {self.assunto}"

    class Meta:
        verbose_name = "Mensagem de Contato"
        verbose_name_plural = "Mensagens de Contato"
        ordering = ['-data_envio']
```

- **`models.EmailField`**: 
    - Valida se o texto inserido tem formato de e-mail.
    
- **`models.BooleanField`**: 
    - Representa `True` ou `False`. 
    - Ideal para marcar a mensagem como "lida". 
    - `default=False` garante que toda nova mensagem comece como "n√£o lida".


#### ü§π O Modelo `Comentario`

Utilizado para permitir que os usu√°rios comentem nos produtos. Cada coment√°rio pertence a um produto e a um usu√°rio.

```python
class Comentario(models.Model):
    produto = models.ForeignKey(
        Produto, 
        on_delete=models.CASCADE, 
        related_name='comentarios'
    )
    autor = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name='comentarios'
    )
    texto = models.TextField()
    data_publicacao = models.DateTimeField(auto_now_add=True)
    aprovado = models.BooleanField(default=True)

    def __str__(self):
        return f'Coment√°rio de {self.autor.username} em {self.produto.nome}'

    class Meta:
        verbose_name = "Coment√°rio"
        verbose_name_plural = "Coment√°rios"
        ordering = ['-data_publicacao']
```

* **`models.ForeignKey`**: 
    - Este √© o campo mais importante para criar **relacionamentos**.
    
* **`produto = models.ForeignKey(Produto, ...)`**: 
    - Diz que cada `Comentario` est√° ligado a um `Produto`.
    
* **`autor = models.ForeignKey(User, ...)`**:

    - Liga o coment√°rio ao usu√°rio que o escreveu. 
    
    - **`User`** √© o modelo de usu√°rio padr√£o do Django.
    
* **`on_delete=models.CASCADE`**: 
    - Significa que, se um produto for exclu√≠do, todos os coment√°rios associados a ele tamb√©m ser√£o.
    
* **`related_name='comentarios'`**: 
    -  Cria um "atalho". 
    -  A partir de um objeto **`Produto`**, podemos acessar seus coment√°rios com **`produto.comentarios.all()`**.

#### üí∞ Os Modelos `Compra` e `ItemCompra`

A partir destes modelos ser√° poss√≠vel registrar uma venda, neste caso precisamos de duas tabelas: uma para a compra em si (quem comprou, quando, qual o total) e outra para os itens dentro dessa compra (quais produtos, a quantidade de cada um).

```python
# site_loja/models.py (continue no mesmo arquivo)

class Compra(models.Model):
    class StatusCompra(models.TextChoices):
        PAGAMENTO_PENDENTE = 'Pendente', 'Pagamento Pendente'
        PROCESSANDO = 'Processando', 'Processando'
        ENVIADO = 'Enviado', 'Enviado'
        ENTREGUE = 'Entregue', 'Entregue'
        CANCELADO = 'Cancelado', 'Cancelado'

    cliente = models.ForeignKey(User, on_delete=models.PROTECT, related_name='compras')
    data_compra = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=20,
        choices=StatusCompra.choices,
        default=StatusCompra.PAGAMENTO_PENDENTE
    )
    
    def __str__(self):
        return f'Compra #{self.id} - {self.cliente.username}'
    
    # Esta fun√ß√£o calcularia o total da compra
    def get_total(self):
        total = sum(item.get_custo() for item in self.itens.all())
        return total

    class Meta:
        verbose_name = "Compra"
        verbose_name_plural = "Compras"
        ordering = ['-data_compra']

class ItemCompra(models.Model):
    compra = models.ForeignKey(Compra, on_delete=models.CASCADE, related_name='itens')
    produto = models.ForeignKey(Produto, on_delete=models.PROTECT, related_name='itens_comprados')
    preco_unitario = models.DecimalField(max_digits=10, decimal_places=2)
    quantidade = models.PositiveIntegerField()

    def __str__(self):
        return f'{self.quantidade}x {self.produto.nome} na Compra #{self.compra.id}'
    
    # Esta fun√ß√£o calcula o custo deste item (pre√ßo x quantidade)
    def get_custo(self):
        return self.preco_unitario * self.quantidade

    class Meta:
        verbose_name = "Item de Compra"
        verbose_name_plural = "Itens de Compra"

```

* **`StatusCompra`**: 
    - Usar uma subclasse **`TextChoices`** √© a forma moderna e recomendada no Django para criar campos com op√ß√µes pr√©-definidas.
    
* **`on_delete=models.PROTECT`**: 
    - Diferente do **`CASCADE`**, isso **impede que um usu√°rio ou produto seja exclu√≠do se houver compras associadas a ele**, protegendo o hist√≥rico de vendas.
    
* **Rela√ß√£o `Compra` e `ItemCompra`**: 
    - Uma `Compra` pode ter v√°rios `ItemCompra` (um para cada tipo de produto no carrinho). Isso √© um relacionamento `ForeignKey` cl√°ssico.
    
* **Por que `preco_unitario` em `ItemCompra`?**: 
    - Guardamos o pre√ßo no momento da compra. 
    - Se o pre√ßo do produto mudar no futuro, o registro hist√≥rico da compra permanecer√° com o valor correto.

#### Modelo: `Perfil`

O Django j√° tem um modelo **`User`** com login, email e senha. Para adicionar informa√ß√µes extras como uma foto, a melhor pr√°tica √© criar um modelo **`Perfil`** e conect√°-lo ao **`User`**.

‚ö†Ô∏è **Aten√ß√£o:** 
- O c√≥digo abaixo usa a biblioteca **Pillow** para manipular imagens. Se voc√™ ainda n√£o a tem, instale-a no seu terminal com o comando:
>
> ```bash
> pip install Pillow
> ```

```python
##
# MODELO DE PERFIL
##
class Perfil(models.Model):
    usuario = models.OneToOneField(User, on_delete=models.CASCADE)
    imagem = models.ImageField(default='perfil_padrao.jpg', upload_to='imagens_perfil')

    def __str__(self):
        return f'Perfil de {self.usuario.username}'
   
    ##
    # Este m√©todo √© executado toda vez que o perfil √© salvo
    ##
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)       # <-- Salva o objeto primeiro

        img = Image.open(self.imagem.path)  # <-- bre a imagem do perfil salva

        # Se a imagem for maior que 300x300 pixels, ela ser√° redimensionada
        if img.height > 300 or img.width > 300:
            output_size = (300, 300)
            img.thumbnail(output_size)      # <-- Redimensiona mantendo a propor√ß√£o
            img.save(self.imagem.path)      # <-- Salva a imagem menor por cima da original

```

* **`usuario = models.OneToOneField(User, ...)`**: 
    - Esta √© a "cola" especial que liga um Perfil a exatamente um Usu√°rio. √â uma rela√ß√£o um-para-um.
    
* **`on_delete=models.CASCADE`**: 
    Se um usu√°rio for deletado, seu perfil ser√° deletado junto. 
    
* **`save()`**: 
    - Estamos **sobrescrevendo** o m√©todo `save` padr√£o do Django. 
    - Isso nos d√° um poder extra: toda vez que um perfil for salvo (seja na cria√ß√£o ou na atualiza√ß√£o), nosso c√≥digo de redimensionamento de imagem ser√° executado automaticamente. 
    - Isso √© √≥timo para economizar espa√ßo e manter o layout do site consistente.


üìù **C√≥digo completo e atualizado para `site_loja/models.py`:**

```python
# site_loja/models.py
from django.db import models

# Importa o modelo de usu√°rio padr√£o do Django
from django.contrib.auth.models import User 

# Importa o Image para redimensionar a imagem
from PIL import Image                       

# Importando o modelo Produto da outra aplica√ß√£o (Aula 12.02.02)
from produtos.models import Produto

##
# Perfil do usu√°rio
##
class Perfil(models.Model):
    usuario = models.OneToOneField(User, on_delete=models.CASCADE)
    imagem = models.ImageField(default='perfil_padrao.jpg', upload_to='imagens_perfil')

    def __str__(self):
        return f'Perfil de {self.usuario.username}'

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs) # Salva a imagem primeiro

        img = Image.open(self.imagem.path) # Abre a imagem
        if img.height > 300 or img.width > 300: # Verifica se √© maior que 300x300 pixels
            output_size = (300, 300)
            img.thumbnail(output_size) # Redimensiona a imagem
            img.save(self.imagem.path) # Salva a imagem redimensionada

##
# Modelo - Contatos (Aula 11.02.02) (Aula 12.02.02)
##
class ContactRequest(models.Model):
    nome = models.CharField(
        max_length=150, 
        verbose_name="Nome"
        )
    
    email = models.EmailField(
        verbose_name="E-mail"
        )
    
    assunto = models.CharField(
        max_length=150,
        default='Sem assunto', 
        blank=True 
        )
    
    mensagem = models.TextField(
        verbose_name="Mensagem"
        )
    
    # Campos de data
    data_criacao = models.DateTimeField(
        auto_now_add=True
        )
    
    data_atualizacao = models.DateTimeField(
        auto_now=True, 
        verbose_name="Enviado em"
        )
    
    lido = models.BooleanField(
        default=False, 
        help_text="Marca se a mensagem foi lida"
        )

    def __str__(self):
        return f"{self.nome} - {self.assunto}"

    class Meta:
        verbose_name = "Mensagem de Contato"
        verbose_name_plural = "Mensagens de Contato"
        ordering = ['-data_criacao']

##
# Modelo - Coment√°rio (Aula 12.02.02)
##
class Comentario(models.Model):
    produto = models.ForeignKey(
        Produto, 
        on_delete=models.CASCADE, 
        related_name='comentarios'
    )

    autor = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name='comentarios'
    )

    texto = models.TextField()

    data_publicacao = models.DateTimeField(auto_now_add=True)

    aprovado = models.BooleanField(default=True)

    def __str__(self):
        return f'Coment√°rio de {self.autor.username} em {self.produto.nome}'

    class Meta:
        verbose_name = "Coment√°rio"
        verbose_name_plural = "Coment√°rios"
        ordering = ['-data_publicacao']

##
# Modelo - Compra (Aula 12.02.02)
##
class Compra(models.Model):
    class StatusCompra(models.TextChoices):
        PAGAMENTO_PENDENTE = 'Pendente', 'Pagamento Pendente'
        PROCESSANDO = 'Processando', 'Processando'
        ENVIADO = 'Enviado', 'Enviado'
        ENTREGUE = 'Entregue', 'Entregue'
        CANCELADO = 'Cancelado', 'Cancelado'

    cliente = models.ForeignKey(
        User, on_delete=models.PROTECT, 
        related_name='compras'
    )
    
    data_compra = models.DateTimeField(auto_now_add=True)

    status = models.CharField(
        max_length=20,
        choices=StatusCompra.choices,
        default=StatusCompra.PAGAMENTO_PENDENTE
    )
    
    def __str__(self):
        return f'Compra #{self.id} - {self.cliente.username}'
    
    # Esta fun√ß√£o calcularia o total da compra
    def get_total(self):
        total = sum(item.get_custo() for item in self.itens.all())
        return total

    class Meta:
        verbose_name = "Compra"
        verbose_name_plural = "Compras"
        ordering = ['-data_compra']

##
# Modelo - Intem da Compra (Aula 12.02.02)
##
class ItemCompra(models.Model):
    compra = models.ForeignKey(
        Compra, 
        on_delete=models.CASCADE, 
        related_name='itens'
    )

    produto = models.ForeignKey(
        Produto, 
        on_delete=models.PROTECT, 
        related_name='itens_comprados'
    )

    preco_unitario = models.DecimalField(
        max_digits=10, 
        decimal_places=2
    )

    quantidade = models.PositiveIntegerField()

    def __str__(self):
        return f'{self.quantidade}x {self.produto.nome} na Compra #{self.compra.id}'
    
    # Esta fun√ß√£o calcula o custo deste item (pre√ßo x quantidade)
    def get_custo(self):
        return self.preco_unitario * self.quantidade

    class Meta:
        verbose_name = "Item de Compra"
        verbose_name_plural = "Itens de Compra"
```

### üèóÔ∏è Construindo o Banco de Dados: As Migra√ß√µes

Agora que temos as "plantas baixas" (**`models.py`**), precisamos dar a ordem para o Django construir as tabelas no banco de dados. Esse processo tem dois passos: **`makemigrations`** e **`migrate`**.

Abra o terminal na pasta raiz do seu projeto (onde est√° o arquivo **`manage.py`**).

#### :one: Criando os "Planos de Constru√ß√£o" (`makemigrations`)

Este comando l√™ todos os seus arquivos **`models.py`**, compara com o estado atual do banco de dados e cria os arquivos de instru√ß√£o (as migra√ß√µes) para aplicar as mudan√ßas.

```bash
python manage.py makemigrations produtos site_loja
```

Voc√™ ver√° uma sa√≠da parecida com esta:
```
Migrations for 'produtos':
  produtos/migrations/0001_initial.py
    - Create model Produto
Migrations for 'site_loja':
  site_loja/migrations/0001_initial.py
    - Create model Contato
    - Create model Compra
    - Create model Comentario
    - Create model ItemCompra
```

Isso confirma que o Django entendeu nossos modelos e criou os "planos" dentro da pasta **`migrations`** de cada aplica√ß√£o.

#### :two: Executando a Obra (`migrate`)

Este comando pega os arquivos de migra√ß√£o que acabamos de criar e os executa, criando ou alterando as tabelas no seu banco de dados.

```bash
python manage.py migrate
```

A sa√≠da mostrar√° cada migra√ß√£o sendo aplicada:

```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, produtos, sessions, site_loja
Running migrations:
  Applying produtos.0001_initial... OK
  Applying site_loja.0001_initial... OK
  ...
```

üéØ **Pronto\!** 
- Neste momento, seu banco de dados foi configurado exatamente como definimos nas nossas classes de modelo. 
- As tabelas `produtos_produto`, `site_loja_contato`, `site_loja_compra`, etc., agora existem e est√£o prontas para receber dados.

### üöÄ Pr√≥ximos Passos

Acabamos de realizar uma das tarefas mais importantes de um projeto Django: a modelagem e cria√ß√£o do banco de dados.

Nos criamos uma estrutura de dados s√≥lida e relacional para uma loja virtual, definindo:

  * Como armazenar **produtos** e seu **estoque**.
  * Como receber **mensagens de contato** dos clientes.
  * Como registrar **coment√°rios** nos produtos.
  * Como gerenciar um sistema robusto de **compras e seus itens**.

A partir daqui, os pr√≥ximos passos no desenvolvimento seriam:

1.  **Registrar os Models no Admin:** Para que voc√™ possa adicionar, editar e excluir dados facilmente atrav√©s da interface de administra√ß√£o do Django.
2.  **Criar as Views:** A l√≥gica que vai buscar os dados do banco e prepar√°-los para serem exibidos.
3.  **Desenvolver os Templates:** Os arquivos HTML que, junto com o Bootstrap, formar√£o a interface visual da sua loja.
